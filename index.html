<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    height: 100%;
    width: 100%;
    font: monospace, sans-serif;
    font-size: 1rem;
  }
  canvas {
    position: absolute;
    top: 0; left: 0;
    touch-action: none;
  }
  select {
    position: absolute;
    bottom: 0px;
    left: 0%;
    padding: 0.5rem;
    margin: 0.75rem;
    border: none;
    border-radius: 5px;
    font-size: 1rem;
  }
  #colorInfo {
    position: absolute;
    bottom: 0px;
    right: 0px;
    padding-right: 0.5rem;
    margin-right: 0.75rem;
    text-align: right;
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<select id="colorMode">
  <option value="rgb">RGB</option>
  <option value="hsl">HSL</option>
</select>
<div id="colorInfo"></div>
<script>
  const canvas = document.getElementById('c')
  const ctx = canvas.getContext('2d')
  const select = document.getElementById('colorMode')
  const colorInfo = document.getElementById('colorInfo')
  let width = window.innerWidth, height = window.innerHeight
  canvas.width = width; canvas.height = height
  
  let z = 0
  let mode = select.value
  
  function hsvToRgb(h, s, v) {
    h = h % 360;
    s = s; v = v;
    s = s/100; v = v/100;
    let c = v * s;
    let x = c * (1 - Math.abs((h / 60) % 2 - 1));
    let m = v - c;
    let r1, g1, b1;
    if (h < 60)      { r1 = c; g1 = x; b1 = 0; }
    else if (h < 120){ r1 = x; g1 = c; b1 = 0; }
    else if (h < 180){ r1 = 0; g1 = c; b1 = x; }
    else if (h < 240){ r1 = 0; g1 = x; b1 = c; }
    else if (h < 300){ r1 = x; g1 = 0; b1 = c; }
    else             { r1 = c; g1 = 0; b1 = x; }
    return [
      Math.round((r1 + m) * 255),
      Math.round((g1 + m) * 255),
      Math.round((b1 + m) * 255)
    ];
  }
  function hslToRgb(h, s, l) {
    h = h/360; s = s/100; l = l/100;
    let r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      const hue2rgb = function(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
  }

  function colorFromXY(x, y, z) {
    let fx = x/width, fy = y/height
    if (mode === 'rgb') {
      return `rgb(${fy*255},${fx*255},${z*255})`
    } else {
      const h = fx*360, s = fy*100, l = z*100;
      const [r, g, b] = hslToRgb(h, s, l);
      return `rgb(${r},${g},${b})`;
    }
  }

  let lastPointer = {x: width-1, y: height-1};

  function pad3(val) {
    // Pad to 3 digits, but don't show useless zeros
    val = Math.round(val).toString();
    return val.padStart(3, ' ');
  }

  function getColorValues(x, y, z) {
    let fx = x/width, fy = y/height;
    // RGB
    let r = fy*255, g = fx*255, b = z*255;
    // HSL
    let h_hsl = fx*360, s_hsl = fy*100, l_hsl = z*100;
    // Pad and align values for pretty output
    const hex = `HEX: #${((1 << 24) + (Math.round(r) << 16) + (Math.round(g) << 8) + Math.round(b)).toString(16).slice(1).toUpperCase()}`;
    const rgb = `RGB: ${pad3(r)}, ${pad3(g)}, ${pad3(b)}`;
    const hsl = `HSL: ${pad3(h_hsl)}, ${pad3(s_hsl)}, ${pad3(l_hsl)}`;
    return { hex, rgb, hsl };
  }

  function getOverlayTextColor(x, y, z) {
    // Get the actual canvas color as rendered
    let fx = x/width, fy = y/height;
    let r = fy*255, g = fx*255, b = z*255;
    // Calculate luminance
    let lum = getLuminance(r, g, b);
    // Invert luminance for text color
    let inv = Math.round((1 - lum + 0.5) * 255);
    return `rgb(${inv},${inv},${inv})`;
  }

  function drawOverlay(x, y, z) {
    // Update the colorInfo div instead of drawing on canvas
    const values = getColorValues(x, y, z);
    colorInfo.innerHTML = `<pre>${values.hex}\n${values.rgb}\n${values.hsl}</pre>`;
    colorInfo.style.color = getOverlayTextColor(x, y, z);
  }

  // Always use lastPointer for color selection, except if never moved, use center
  function updateCanvas() {
    ctx.clearRect(0, 0, width, height);
    let px = lastPointer.x, py = lastPointer.y;
    if (px === width - 1 && py === height - 1) {
      px = width / 2;
      py = height / 2;
    }
    ctx.fillStyle = colorFromXY(px, py, z);
    ctx.fillRect(0, 0, width, height);
    drawOverlay(px, py, z);
    updateColorInfo(px, py, z);
  }

  function updateColorInfo(x, y, z) {
    // Keep this in sync with drawOverlay for alignment
    const values = getColorValues(x, y, z);
    colorInfo.innerHTML = `<pre>${values.hex}\n${values.rgb}\n${values.hsl}</pre>`;
  }

  let updateRequested = false;
  function requestUpdate() {
    if (!updateRequested) {
      updateRequested = true;
      requestAnimationFrame(() => {
        updateRequested = false;
        updateCanvas();
      });
    }
  }

  canvas.addEventListener('pointermove', e => {
    lastPointer = {x: e.clientX, y: e.clientY};
    requestUpdate();
  });

  window.addEventListener('wheel', e => {
    z += e.deltaY * -0.0001;
    if (z < 0) z = 0;
    if (z > 1) z = 1;
    requestUpdate();
  });

  select.addEventListener('change', e => {
    mode = e.target.value;
    requestUpdate();
  });

  window.addEventListener('resize', () => {
    width = window.innerWidth; height = window.innerHeight;
    canvas.width = width; canvas.height = height;
    requestUpdate();
  });

  // Mobile touch handling
  let lastTouchY = null, lastTouchTime = 0, swipeCount = 0, lastTouchX = null, lastZ = z;
  canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
      lastTouchY = e.touches[0].clientY;
      lastTouchX = e.touches[0].clientX;
    } else if (e.touches.length === 2) {
      lastTouchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
      lastZ = z;
    }
    e.preventDefault();
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 1 && lastTouchY !== null && lastTouchX !== null) {
      // Single finger: move pointer
      lastPointer = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      requestUpdate();
    } else if (e.touches.length === 2 && lastTouchY !== null) {
      // Two fingers: adjust z
      const avgY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
      const dy = avgY - lastTouchY;
      z = lastZ - dy * 0.003; // Sensitivity
      if (z < 0) z = 0;
      if (z > 1) z = 1;
      requestUpdate();
    }
    e.preventDefault();
  }, { passive: false });

  canvas.addEventListener('touchend', e => {
    if (e.touches.length === 0) {
      lastTouchY = null;
      lastTouchX = null;
    }
    e.preventDefault();
  }, { passive: false });

  function getLuminance(r, g, b) {
    // sRGB luminance(Y) formula
    r /= 255; g /= 255; b /= 255;
    r = r <= 0.03928 ? r/12.92 : Math.pow((r+0.055)/1.055, 2.4);
    g = g <= 0.03928 ? g/12.92 : Math.pow((g+0.055)/1.055, 2.4);
    b = b <= 0.03928 ? b/12.92 : Math.pow((b+0.055)/1.055, 2.4);
    return 0.2126*r + 0.7152*g + 0.0722*b;
  }

  // Initial draw
  requestUpdate();
</script>
</body>
</html>
