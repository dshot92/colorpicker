<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    height: 100%;
    width: 100%;
  }
  canvas {
    position: absolute;
    top: 0; left: 0;
  }
  select {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    padding: 0.5rem;
    background: rgba(255,255,255,0.8);
    border: none;
    border-radius: 5px;
    font-size: 1rem;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<select id="colorMode">
  <option value="rgb">RGB</option>
  <option value="hsv">HSV</option>
  <option value="hsl">HSL</option>
</select>
<script>
  const canvas = document.getElementById('c')
  const ctx = canvas.getContext('2d')
  const select = document.getElementById('colorMode')
  let width = window.innerWidth, height = window.innerHeight
  canvas.width = width; canvas.height = height
  
  let z = 0
  let mode = select.value
  
  function colorFromXY(x, y, z) {
    let fx = x/width, fy = y/height
    if (mode === 'rgb') {
      return `rgb(${fy*255},${fx*255},${z*255})`
    } else if (mode === 'hsv') {
      const h = fx*360, s = fy, v = z
      return `hsv(${h},${s*100}%,${v*100}%)`
    } else {
      const h = fx*360, s = fy*100, l = z*50
      return `hsl(${h},${s}%,${l}%)`
    }
  }

  let lastPointer = {x: width-1, y: height-1};

  function getColorValues(x, y, z) {
    let fx = x/width, fy = y/height;
    // RGB
    let r = Math.round(fy*255), g = Math.round(fx*255), b = Math.round(z*255);
    // HSV
    let h_hsv = Math.round(fx*360), s_hsv = Math.round(fy*100), v_hsv = Math.round(z*100);
    // HSL
    let h_hsl = Math.round(fx*360), s_hsl = Math.round(fy*100), l_hsl = Math.round(z*50);
    return {
      rgb: `rgb:${r},${g},${b}`,
      hsv: `hsv:${h_hsv},${s_hsv},${v_hsv}`,
      hsl: `hsl:${h_hsl},${s_hsl},${l_hsl}`
    };
  }

  function drawOverlay(x, y, z) {
    const margin = 16;
    const lines = Object.values(getColorValues(x, y, z));
    ctx.save();
    ctx.font = '16px monospace';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';
    ctx.globalAlpha = 0;
    // background box
    const lineHeight = 22;
    const boxWidth = Math.max(...lines.map(l => ctx.measureText(l).width)) + 20;
    const boxHeight = lineHeight * lines.length + 10;
    ctx.fillStyle = '#fff';
    ctx.fillRect(width - boxWidth - margin, height - boxHeight - margin, boxWidth, boxHeight);
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#222';
    lines.forEach((line, i) => {
      ctx.fillText(line, width - margin, height - margin - (lines.length-1-i)*lineHeight);
    });
    ctx.restore();
  }

  // Always use lastPointer for color selection, except if never moved, use center
  function updateCanvas() {
    ctx.clearRect(0, 0, width, height);
    let px = lastPointer.x, py = lastPointer.y;
    if (px === width - 1 && py === height - 1) {
      px = width / 2;
      py = height / 2;
    }
    ctx.fillStyle = colorFromXY(px, py, z);
    ctx.fillRect(0, 0, width, height);
    drawOverlay(px, py, z);
  }

  canvas.addEventListener('pointermove', e => {
    lastPointer = {x: e.clientX, y: e.clientY};
    updateCanvas();
  });

  window.addEventListener('wheel', e => {
    z += e.deltaY * -0.0001;
    if (z < 0) z = 0;
    if (z > 1) z = 1;
    updateCanvas();
  });

  select.addEventListener('change', e => {
    mode = e.target.value;
    updateCanvas();
  });

  window.addEventListener('resize', () => {
    width = window.innerWidth; height = window.innerHeight;
    canvas.width = width; canvas.height = height;
    updateCanvas();
  });

  // Mobile double swipe detection
  let lastTouchY = null, lastTouchTime = 0, swipeCount = 0;
  canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
      lastTouchY = e.touches[0].clientY;
    }
  });
  canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 1 && lastTouchY !== null) {
      const dy = e.touches[0].clientY - lastTouchY;
      const now = Date.now();
      if (Math.abs(dy) > 50 && now - lastTouchTime < 400) {
        swipeCount++;
        if (swipeCount === 2) {
          z += dy < 0 ? 0.05 : -0.05;
          if (mode === 'rgb') updateCanvas();
          swipeCount = 0;
        }
        lastTouchTime = now;
      }
      lastTouchY = e.touches[0].clientY;
    }
  });
  canvas.addEventListener('touchend', e => {
    lastTouchY = null;
    setTimeout(() => { swipeCount = 0; }, 500);
  });

  // Initial draw
  updateCanvas();
</script>
</body>
</html>
